1. Introduction
===============

The world wide web has become world's largest system based on the internet. Development has evolved from simple static websites built in HTML and CSS to N-Tier applications. N-Tier applications are distributed over separate machines, where each machine runs and persists different parts of the behavior. Different software architectural styles have been evolved from N-Tier applications, tailored around the needs of distributed systems. In web applications, this evolution let to a switch from service oriented services to microservices as an architectural style, which are widely used in the mainstream development of web applications **[Microservices O'reilly]**. Web applications are not only growing in size, but especially in their data usage. Todays web applications have to process large amounts of data, but still need to fulfil non-functional requirements such as responding to the user in acceptable short time frames. This evolution can also be found in programming paradigms and techniques, where new technologies are designed from the ground up with distribution and concurrency in mind.

A programming paradigm that is becoming more popular in the development of distributed web applications is reactive programming **[Typesafe white paper]**. Reactive programming will be the central paradigm used in this paper to fulfil the distributed needs of today's web applications. To understand Reactive Programming a document called 'The Reactive Manifesto' will be used in this paper. The Reactive Manifesto is a document constructed by experts in the field of reactive programming to provide an high-level overview of the paradigm. The document argues that a reactive program needs to consists of four traits, namely _message/event driven_, _resilliency_, _elasticity_ which leads to the application being _responsive_. An application is event driven when it reacts and executes certain actions based on these events. Resiliency can be achieved by using different approaches, for instance the implementation of the actor model in the library Akka uses a hierarchical structure to provide recovering strategies. In event-driven systems, events are push- instead of polling-based, this makes them more suitable for replication on distributed applications. Elasticity in reactive applications provides the ability of staying responsive under varying workloads. This has to be achieved dynamically based on the current (reactive) or historical (pro-active) work-loads. When an application detects a higher workload, a number of new instances can be created to automatically balance the workload. When the workload decreases, a number of instances can be shut down. By designing distributed programs with the reactive programming paradigm, programs should be able to scale well. However, dynamically creating or removing replication instances for achieving elasticity is an external dependency from the actual web applications.

Currently, cloud providers such as Amazon Web Services (AWS) [source], Microsoft Azure [source], Google Cloud Platform [source] and other third party cloud applications such as Kubernetes [source] and Mesos [source] offer mechanisms to help users achieve auto-scaling web services. The internal workings of these provided services work, however each individual application has to use different strategies to have correct auto-scaling for the needs of that specific application. The workings of these strategy need to be validated by testing just as much as the internal workings of an application needs to be tested. Not understanding how an application works under different loads or what the limitations are, may result in an ineffective or even destructive auto scaling configuration. This introduces the central question of this paper:

### _How should reactive web applications be validated in their elasticity?_

To answer the central question this paper uses several subquestions:

*   How is Elasticity achieved in web applications?
*   What are the requirements of a web application to be able to scale in an elastic fashion?
*   How can user traffic be simulated with increasing and decreasing volumes?

The validate elasticity strategies, this paper introduces ElasticityTest, an web application that can test and validate the workings of an application its auto-scaling capabilities. The user of ElasticityTest can provide a number of Unique Resource Identifiers (URIs) accompanied with several request per second (req/sec) intervals to create user traffic simulations to validate the specific elasticity strategy. By providing web hooks to the elasticity mechanism provider, for instance AWS, the number of instances can be measured during the execution of the test. By comparing the response times and response results with the number of instances of the web application, the elasticity strategy can be validated or adjusted to its needs. This paper introduces Reactive Programming for background information, Elasticity in more depth and an overview, the design and implementation of ElasticityTest, accompanied with a test application and its elasticity strategy validation.

The remainder of this paper is organized as follows. Section 2 provides an overview of related work. Section 3 introduces reactive programming, from an high-overview perspective to provide the needed background information for the rest of the paper. In section 4 Elasticity will be covered in more depth than the higher level overview in Section 3. The ElasticityTest service will be introduced in section 5 as a solution for validating the workings of elasticity strategies of web applications. In section 6 an special designed test application gets validated with ElasticityTest. Section 7 covers the results of section 6. Finally, the papers ends with a discussion and conclusion in section 7 and 8 respectively.
